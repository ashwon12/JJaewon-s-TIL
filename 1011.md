# 10월 11일 TIL

## Linux

### Process status

: 생성되서 종료될때 까지 여러 상태를 거친다. 

- create
- running : running 은 무조건 1개만 가능하다.
- ready
- sleeping
- zombie : 프로세스는 남았지만 메모리나 cpu가 아직 남아 뒤처리가 되지 않은 상태
- 실행과정

process가 생성이 되면 ready 단계로 이동하게 된다. 

준비(ready)에서 실행단계(Running)로 넘어가게 되는데 이 과정을 수행하는 것이 `스케줄러`가 하는 일

ready에서 실행단계로 넘어가지 않을 경우 수면상태로 전환한다.cpu 사용을 하지 않게 된다.

![Untitled](https://user-images.githubusercontent.com/55980680/95686032-6b20a180-0c36-11eb-8ca3-1a57e5038d79.png)

new → ready → runnig

Running 상태에서 입출력이 생기면 wating으로 간다.  입출력이 통상적으로 시간이 많이 소요되기 때문이다.

입출력을 할 준비가 되면 바로 runnig으로 가는게 아니라 다시 ready 상태로 갔다가 다시 running 상태로 움직이는 구조이다.

<br>


### Process termination

![Untitled 1](https://user-images.githubusercontent.com/55980680/95686055-91ded800-0c36-11eb-8091-809dfa67a4b9.png)

`exec()` 시스템 콜을 통해 프로세스가 생성이 되고 `C start-up routine`을 통해 main함수를 호출시킨다. main함수와 main함수 안에 있는 다양한 user 함수에서도 언제든지 `exit()` 시스템 콜을 호출할 수 있다.

1. `exit()`가 호출될 경우 : exit function → **standard I/O cleanup** → _exit
2. `atexit()` 가 호출될 경우 :  exit function → 존재하고 있는 여러개의 **exit handler** → _exit
3. `_exit()`가 호출될 경우 : 바로 종료

- **정상종료가 되는 경우**

    return from main()

    exit()  → 시스템 콜

    ```c
    #include <stdlib.h>

    void exit(int status);

    /* cleanup proceccing
    프로세스가 사용한 모든 것들을 close 시킴
    output 버퍼에 있는 내용을 메모리로 옮김*/
    ```

    _exit()

    ```c
    #include <unistd.h>

    void _exit(int status);

    /*클린 업 작업 없이 바로 커널로 넘긴다.*/
    ```

atexit()

```c
#include <stdlib.h>

void atexit(void (*func)(void);

/* 종료시키면서 일을 시키는 시스템 콜

프로세스 하나 당 함수는 32개 등록시킬 수 있다. 
func() : exit 핸들러

실행 순서 : 젤 마지막에 등록된 함수를 젤 먼저 실행시킴

비정상종료 일 경우 func 실행X */
```

- **비정상 종료**

    abort() , kill()
    
<br>

## 한줄평

알고리즘 공부했던 내용 , 내가 정리해놓은거 조금 복습하고 리눅스 process 부분 공부했다. 이론은 이해가 되는데 직접 코드를 짜는게 쉽지 않다.... C언어부터가 문제인걸까,,, 너무 어렵다.
