# 1월 14일의 TIL

## 1. 람다식

람다식은 익명함수 중 하나 이기 때문에 익명함수가 무엇인지 살펴보아야 한다. 함수를 변수에 담아서 만드는 리터럴 방식으로 만들어진  것을 익명함수라고 한다.  익명함수는 주로 재사용하지 않는 함수를 만들 때 사용한다..

람다식은 아래와 같은 특징이 있다.

- 람다식은 value처럼 다룰 수 있는 익명함수이다.
- 메소드의 파라메터로 넘겨줄 수 있다.
- return 삾으로 사용할 수가 있다.

### 1-1. 람다의 정의

```kotlin
// 람다의 기본 정의
val lamdaName : (a: Int, b: Int) -> Int = { a,b -> a*b}
val lamdaName = { a : Type , b : Type -> a*b }
```

1. 중괄호로 감싼다. {...}
2. 인자와 본문은`→` 로 구분한다.
3. 인자는 ()로 감싸지 않는다.
4. 인자는 형식 추론이 가능하므로 타입을 생략할 수 있다.
5. 변수에 람다식을 담는 경우에는 인자의 타입을 생략할 수 없다.
6. 반환자료형이 없을 경우`() → Unit` 으로 선언
7. 매개변수가 하나 있을 경우 `(Type) → (Type)`으로 선언

```kotlin
val square: (Int) ->(Int)= {number -> number*number}

val nameAge = {name: String ,age : Int ->
    "my name is ${name}  I'm ${age}"
}

fun main(){
    println(square(12))
    println(nameAge("김재원",23))
}
```

### 1-2. 확장함수

```kotlin
val pizzaIsGreat: String.() -> String = {
    this+"pizza is the best"
}

fun main(){
    val a = "김재원이 말하다 "
    val b = "주성민이 말하다 "
		println(a.pizzaIsGreat())
    println(b.pizzaIsGreat())
}

/*
김재원이 말하다 pizza is the best
주성민이 말하다 pizza is the best
*/
```

파라매터를 String.() 의 형태로 받고 String을 반환시키는 익명한수 pizza가 있다. 여기에서 this는 자기 자신을 부르기 때문에 전달받은 a Sring값이 호출되어진다.

```kotlin
fun extendsString(name : String , age : Int): String{
    val introduce : String.(Int) -> String ={"i'm ${this} and ${it} years old"}
    return name.introduce(age)
}

fun main(){
    println(extendsString("김재원",23))
}
```

함수 extendsString은 매개변수로 String타입의 name과 Int 타입의 age를 전달받고 String 을 반환시켜주는 함수이다.

introduce에는 익명함수로 전달받은 자기자신(this = String)과 매개변수가 하나일 때 사용하는 it으로 구성된 문자열을 반환시켜준다.

## 2. Data Class

toString() , hashCode, equals(), copy() 메서드가 자동으로 들어있는 class 

```kotlin
data class Ticket(val companyName : String, val name : String, var date : String, var seatNum : Int)

class NomarlTicket(val companyName : String, val name : String, var date : String, var seatNum : Int)

fun main(){
    val ticketA = Ticket("대한항공","김재원","2020-01-13",14)
    val ticketB = NomarlTicket("대한항공","김재원","2020-01-13",14)
    println(ticketA)
    println(ticketB)

}

/*
출력 결과
Ticket(companyName=대한항공, name=김재원, date=2020-01-13, seatNum=14)
com.example.firstpractice.NomarlTicket@61bbe9ba
*/
```

data class는 tostring메서드가 있기 때문에 파라메터들을 출력하게 되고 일반 class에는 아무것도 선언되어 있지 않기 때문에 객체의 참조값이 출력된다.

## 3.Companian object

자바에서 static 역할을 해주는 것이다. 클래스 변수와 클래스 메서드처럼 사용하게 된다. interface도 가능하다.

```kotlin
class Book private constructor(val id: Int , val name : String){

    companion object BookFactory : IdProvider{
        val myBook = "new Book"

        override fun getId(): Int {
            return 444
        }
        fun create() = Book(getId(), myBook)
    }
}

interface IdProvider{
    fun getId() : Int
}
fun main(){
    val book = Book.create()

    val bookId = Book.BookFactory.getId()
    println("${book.id} ${book.name} ${bookId}")
}
```

## 4.Object

object 객체를 모든 앱을 실행할 때 딱 한번만 실행된다. == 싱글턴 패턴

불필요하게 메모리가 사용되는 것을 막을 수 있다. 

object를 선언하면 클래스 선언과 동시에 객체가 생성된다.

```kotlin
object CarFactory {
    val cars = mutableListOf<Car>()

    fun makkeCar(Power : Int) : Car {
        val car = Car(Power)
        cars.add(car)
        return car
    }
}

data class Car(val Power : Int)

fun main(){
    val car = CarFactory.makkeCar(10)
    val car2 = CarFactory.makkeCar(200)

    println(car)
    println(car2)
    println(CarFactory.cars.size.toString())
}
```
