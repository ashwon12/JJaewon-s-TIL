# 1월 4일의 TIL

## Kotlin 기본문법2

<br>

## 7. Nullable / NonNull

자바에서는 NPE를 컴파일 시점에서 잡을 수 없고 런타임 시점에서만 체크할 수 있기 때문에 런타임 오류로 많이 발생한다.

코틀린에서는 ***컴파일 시점에서 null 체크***를 해주므로 매우 편하다!!

### 7-1. ? 연산자

- null 값이 들어갈 수 있는 변수를 선언할 때는 type 뒤에 ?를 붙여준다.

```kotlin
var name : String = "jaewon"
var nullName : String? = null
```

- null 값인지 체크하기 위해서는 변수명 뒤에 ?를 붙여준다.

```kotlin
var nameInUperCase : String = name.toUpperCase()
var NullNameUPerCase : String? = nullName?.toUpperCase()
// nullName 변수가 null 값이면 'null'을 반환하고 null이 아니면
// 메서드를 실행시킨다.  nullName 뒤에 ?가 붙지 않으면 컴파일오류
```

<br>

### 7-2. ?: 엘비스연산자

- 변수가 null 일 때 디폴트 값을 주거나 null 값을 변환할 수 있는 함수의 결과를 만들어 준다.

```kotlin
val lastname : String? = null

val fullname : String? = name+" "+(lastname?: "No lastName")
val name1 : String? = lastname?: return
val name2 : String? = lastname?: throw NullPointerException()
```

<br>

### 7-3.  !!

- 선언된 값이 절대절대 null이 아닐경우 !! 연산자로 선언을 해주면 뒤에서 계속 null값 체크를 하지 않아도 된다.

```kotlin
fun ignoreNull(str : String?){
    val mNotNull : String = str!!
    val upper = mNotNull.toUpperCase()
}
```

str이 null값이 아니라고 보증을 하였기 때문에 두번째 실행문에서 ?를 적지 않아도 에러가 발생하지 않는다.

<br>

### 7-4. ?.

- null을 안전하게 처리하기 위해 사용한다. null이 아닐때 오른쪽에 있는 함수가 실행되고 아니면 null을 반환한다.

```kotlin
val email : String? = "ashwon12"
    email?.let {
        println("my email is ${email}")
    }
```

<br><br>

## 8. Class

- 자바와 다르게 파일명과 클래스 이름이 일치하지 않아도 된다.

### 8-1. class 생성

```kotlin
class Person constructor(val name : String = "익명"){
    open fun eatingCake(){
        println("${name}이 말하길,,,케이크는 맛있다!")
    }
}

fun main(){
		val person1 = Person("jaewon")
		val person2 = Person()
		person1.eatingCake()
		person2.eatingCake()
}

/* 
출력
jaewon이 말하길,,, 케이크는 맛있다! 
익명이 말하길,,, 케이크는 맛있다! 
*/
```

- 기본생성자는 클래스 선언문 옆 `constructor()`를 통해 생성해준다. 생략하고 괄호만 적어도 된다.
- 매개변수로 전달받는 값은 바로 괄호 옆 생성자로 생성해주고 값이 없다면 초기화 값을 적어줄 수 있다.
- 객체를 생성할 땐 자바와 다르게 `new` 를 생략해서 적어준다.

<br>

### 8-2. 부생성자과 init생성자

```kotlin
class Person constructor(val name : String = "익명" ){
    init {
        println("주 생성자의 일부!, 객체 생성!")
				println("person is ${name}")
    }

    constructor(name : String, age : Int) : this(name){
        println("my name is ${name}, age is ${age}")
    }
}

fun main(){
    val person = Person("jaewon")
    val person2 = Person()
    val sungmin = Person("sungmin",25)
}

/*
출력
주 생성자의 일부!, 객체 생성!
person is jaewon
주 생성자의 일부!, 객체 생성!
person is 익명
주 생성자의 일부!, 객체 생성!
person is sungmin
my name is sungmin, age is 25
*/
```

- init 생성자는 주생성자가 호출될 때마다 호출되는 생성자이다. 객체를 생성하거나 자식클래스의 생성자가 호출할 때 자동으로 호출된다.
- 부생성자는 주생성자에서부터 오기 때문에 주생성자에서 받은 값을 `this()`를 통해 전달시켜주어야 한다.

<br>

### 8-3. 상속과 오버라이딩

```kotlin
open class Person constructor(val name : String = "익명"){
    init {
        println("주 생성자의 일부!, 객체 생성!")
    }

    open fun eatingCake(){
        println("${name}이 말하길,,,케이크는 맛있다!")
    }
}

class onePerson() : Person(){
    override fun eatingCake(){
        //super.eatingCake()
        println("${name}은 cake를 싫어해!")
    }
}

fun main(){
    val person = Person("jaewon")
    person.eatingCake()

    val person2 = onePerson()
    person2.eatingCake()
}

/*
출력
주 생성자의 일부!, 객체 생성!
jaewon이 말하길,,,케이크는 맛있다!
주 생성자의 일부!, 객체 생성!
익명은 cake를 싫어해!
*/

```

- 코틀린에서는 class와 메소드 모두 final로 선언되어 있기 때문에 `open` 명령어가 없으면 상속과 오버라이딩이 불가능하다.
- 상속 선언 방법   `class 자식클래스() : 부모클래스()`

<br><br><br>

## 한줄평
자바를 복습하면서 같이 배우니까 코틀린이랑 비교가 더 쉽게 되는 것 같다.
null체크를 컴파일상태에서 해주는건 직접 코딩하다보면 정말로 편할 것같다.
NPE를 더이상 안만날 수 있다!!!

