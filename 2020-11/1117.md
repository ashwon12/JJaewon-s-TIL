# 11월 17일의 TIL

## algorithm

### 분기한정

안내 표지판과 같은 지표를 활용하여 최종 해를 찾는 기법은 '**분기한정**' 이라고 한다. 상대 공간 트리를 이용하고 최적화 문제에만 적용한다. `BFS(best-first-search)`를 사용한다.

노드를 탐색하며 최선의 노드를 찾게 되는데 노드 탐색을 중단하는 이유에는 아래와 같은 이유들이 있다.

1. 노드의 한계값이 그 때까지 찾은 최고 해의 값보다 못하다.
2. 노드의 문제의 제약 사항들을 만족 시키지 못한다
3. 노드가 나타내는 실현 가능한 해들의 부분 집합이 더 이상 추가 선택들을 할 수 없는 경우

#### BFS?

- 최적의 해에 더 빨리 도달하기 위한 전략
- 너비 우선 탐색 사용
- 한 유망한 노드의 모든 자식 노드들을 만든 후 남아있는 유망하나 확장하지 않은 노드들 중 최고의 한계값을 가진 노드를 먼저 확장하게 된다.
- 우선 순위 대기열을 사용한다. ⇒ **큐를 이용하여 구현한다**

#### 너비 우선 탐색

1. 트리의 루트 노드를 먼저 탐색
2. 트리의 수준 1에 있는 모든 모드를 왼쪽에서 오른쪽으로 탐색
3. 수준 2에 있는 모든 모드를 왼쪽에서 오른쪽으로 탐색
4. 마지막 수준까지 이것을 반복

<br>

### 배낭 문제 수도코드
```java
int knapsack2(int n, int[] p, int[] w, int W){
// n : 물건들의 수
// p : 가치를 저장하는 배열 , w: 물건의 가치를 저장하는 배열
// W : 가방이 담을 수 있는 무게

	queue_of_node Q;
	node u, v;
	int maxprofit; // 최댓값

	initialize(Q); // Q를 빈 배열로 초기화
	v.level = 0;   // 상대공간트리의 수준
	v.profit = 0;   
	v.weight = 0;

	maxprofit = 0;
	enqueue(Q, v);

	while( !empty(Q)){
		dequeue(Q, v);
		u.level = v.level + 1; // u를 v의 자식마디로
		u.weight = v.weight + w[u.level]; // u를 다음 아이템을 포함하는 자식마디로 놓음
		u.profit = v.profit + p[u.level];

		if( u.weight <= W && u.profit > maxprofit )
			maxprofit = u.profit;
		if( bound(u) > maxprofit )
			enqueue(Q, u);

		u.weight = v.weight; // u를 v의 자식마디로 놓되 다음 아이템을 포함하지 않는 자식마디로 놓은
		u.profit = v.profit;
		if( bound(u) > maxprofit )
			enqueue(Q, u);
	}
	return maxprofit;
}

float bound( node u){
	index j, k;
	int totalweight;
	float result;

	if(u.weight >= W)
		return 0;
	else if(u.level <N) 
		j = u.level + 1;
		result = u.profit + (W - u.wwight) x ( p[j]/w[j]) ) 
	else
		result = u.profit

	return result;	
}
```

<br>

## 한줄평

헷갈리던 DFS랑 BFS를 완전히 이해했고 큐에 대해서도 이해했다.

오랜만에 알고리즘을 제대로 공부해서 기부니 조타


