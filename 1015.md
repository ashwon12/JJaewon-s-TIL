# 10월 15일 TIL

<br><br>

# Coputer Security - DES

## 1. 특징

- 파이스텔 네트워트를 사용한 방법

    블락 사이즈 64bit가 들어가면 64bit가 나온다!

    키 길이 56bit

    round 16

    subkey( 라운드마다 키 ) 48bit

- S-boxes 에 의해 결정 되었다.
- **루시퍼 싸이퍼**에 기본이 되어 있다.

    ⇒NSA 에서 약간 수정을 해서 논쟁이 있었음.음모론이 존재함

- 1997년에 키사이즈가 너무 작다라는 문제가 제기
- 2000년에 NIST가 Rijndael 알고리즘이 채택하고 **AES** 로 대체됨

## 2. DES 동작 과정

![Untitled](https://user-images.githubusercontent.com/55980680/96177085-43984480-0f68-11eb-81f1-f0741cfbf67a.png)

키 스케줄링 : 반반으로 나눠서 shift 해준다. 그리고 compress 해서 다음 키 펑션에 넣어준다.

 F 펑션 : 

1. 32bit가 들어오면 K 사이즈과 같게 하기 위해서 expand로 길이를 늘려준다.  32→ 48 bit로 바뀌어짐
2. K 와 XOR 시켜준다. ( R이 k에 의해 Flip이 되는 과정)
3. S-boxes를 통해 사이즈를 32로 다시 줄여준다.

### 2-1 . Expand

F 펑션의 1단계에서 길이를 늘려주기도 하고 약간 섞어주기도 한다.

![Untitled 1](https://user-images.githubusercontent.com/55980680/96177056-3d09cd00-0f68-11eb-91cb-04c73c1f8f2d.png)

31 / 0~4 / 3~8 / 7~12 / 11~16 / 15~20 / 19 ~24 / 23 28 / 27~0 

→ 16 bit가 중복된다.

### 2-2. S-boxes

암호화 알고리즘의 안정성을 보장하는 핵심 `S-boxes`

- 8개의 대체 박스가 있다
- 각각의 6bit를 4bit로 줄여야 한다.
- 6 bit와 4bit가 전혀 관련성이 없어보여야 한다. 
따라서 테이블을 잘 만들어야 한다( 패턴없이 랜덤하게)

### 2-3. P-box

s-box로 섞어준 걸 다시 한번 섞어주는 아이

- 32 bit로 들어가면 32bit로 나온다.
- s-boxes 나 p-box 둘 다 패턴이 없어야 하기 때문에 규칙이 존재하면 안된다!

### 2-4. Subkey

key를 섞어서 약간 다른 키로 만들어줘서 나오는 key

- 56 bit 의 DES 키를 왼쪽 오른쪽 두개로 나눠준다.
- shift를 통해 왼쪽이 Lbit 오른쪽이 Rbit가 된다.

### 2-5 정리

첫번째 라운드 하기 전에 퍼뮤테이션(p-box) 한번 적용

반으로 나눠서 맨 마지막에 스와핑 한번 한다.

→ 보안 목적은 아님

## 3. DES의 보안

- S-boxes에 많이 의존하고 있다.
- **exhaustive key search**에 의해 깨졌다.
- 알고리즘에서는 문제가 없었지만 키의 길이가 짧아서 문제가 발견되었다.
- 그 시대의 앞서간 사람들이 만들었다.
- 지금은 아무도 안쓴다!!

<br><br>

# block cipher mode

블락 사이퍼는 플레인텍스트를 블락별로 나눠서 암호화 한다. 

문제점 : 블락들의 순서가 달라지면 원본이 달라지게 된다! 
SO, 독립적인 것이 아니라 연계가 되게 만들어주는 무언가 = `MODE`

1. ECB → 보안 취약
2. CBC → 시대를 풍미한 보안모드
3. CTR → ramdome access로 유명함
4. CFB
5. OFB
6. GCM → 최근에 사용하는 mode

## ECB MODE

키 하나에 코드북이라는 것이 존재함. 책 처럼 테이블의 값이 정해져있다.

A를 넣어서 B가 나오는데 다음 경우에도 A를 넣으면 B가 온다.

같다라는 사실때문에 k에 대한 정보를 알게 된다. 매우 취약함

- **Paste Attack**

![Untitled 2](https://user-images.githubusercontent.com/55980680/96177065-4004bd80-0f68-11eb-8950-81ddc33f66f1.png)

- 이미지 같은 경우는 제대로 암호화가 되지 않는다.

## CBC MODE

`**체인처럼 묶어서 사용**`하는 모드이다.

1. 첫번째 블락은 랜덤넘버(IV)를 넣어서 XOR 시킨다.
2. 이전블락의 암호문을 다음 암호문에서 XOR 시킨다. 

CBC 모드에서 XOR은 보안을 위해 사용한 것이 아니라 앞 블락과 뒤에있는 블락을 `**연관**`시키기 위해 사용한 것 이다.

### **특징**

- 암호화과정에서는 하나만 틀려도 다 틀린다.
- 복호화 과정에서 ciphertext  첫번째가 틀리면 두번째꺼는 틀리는데 세번째꺼는 안 틀린다.
- 11번째의 블락만 필요해도 그 앞에있는 모든 것들을 다 구해야만 한다. 
⇒ 스트링에는 적절하지 않다.
- 똑같은 텍스트블락도 다른 싸이퍼가 된다.
- 이미지 암호화 가능

### **표현법**

C(0) = E(IV  ⊕ p(0), K)
C(1) = E(C(0) ⊕ p(1),K)
C(2) = E(C(1) ⊕ p(2),K)

P(0) = IV ⊕(C(0),K) = IV ⊕ D(E(IV⊕P(0),K)
P(1) = C(0) ⊕(C(1),K)
P(2) = C(1) ⊕(C(2),K)

### Attack

공격자가 cipher 텍스트에 수정을 하면 그 다음 블락에 영향을 미치게 된다.

i번째 블락을 바꾸고 싶으면 그 전 블락을 바꾸면 된다.

## CTR

스트리밍할 때 문제있음

![Untitled 3](https://user-images.githubusercontent.com/55980680/96177076-42671780-0f68-11eb-881a-fe5e2c4ad3f2.png)

- 블락마다 임의의 카운터를 배정함 , 옆으로 갈 때마가 1씩 증가
- 원하고자하는 블락의 전 부분을 구하지 않아도 된다.
- 카운터가 예측 가능하기 때문에 카운터 암호화를 먼저 한다.

### 표현법

![Untitled 4](https://user-images.githubusercontent.com/55980680/96177079-42ffae00-0f68-11eb-8670-76d55ee160bc.png)

## CFB

![Untitled 5](https://user-images.githubusercontent.com/55980680/96177081-42ffae00-0f68-11eb-93b8-b2a07ab755ee.png)

- IV와 key를 먼저 암호화한다음 플레인텍스트와 ⊕ 시킨다.
- 다음 암호화과정에서는 이전의 싸이퍼텍스트를 key와 암호화 시킨다.
- 체인 방법

## OFB

![Untitled 6](https://user-images.githubusercontent.com/55980680/96177083-43984480-0f68-11eb-9155-03d44d22a0fa.png)

- IV와 key를 먼저 암호화 한다. = A
- A와 플레인텍스트를 XOR 시켜서 싸이퍼텍스트를 만든다.
- 두번쨰 블락에선 A와 key를 암호화한다.
- 노출되는 정보인 싸이퍼텍스트말고 노출되지 않는 정보 A를 이용한다.

<br><br>

## 한줄평

컴퓨터 보안 오랜만에 공부했는데 뭐징뭐징,,, 재밌다,,,,,, 보안은 역사를 배우는 느낌이어서 흐름이 있어서 이해하기가 더 쉽다. 

보안방법의 암호화과정, 복호화과정, 그리고 attack 방법 그래서 새로 등장한 보안방법 이런식으로 흘러가서 공부할 때 시간이 후딱후딱 간다. 집중도 잘 되는 듯하다.
