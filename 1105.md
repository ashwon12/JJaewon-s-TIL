# 11월 5일의 TIL

컴퓨터보안을 배웠다.

# PKI ( public key infrastructure)

pki의 목적 : 인증서 핵심 ( 인증서의 대상 :subject의 public key 값을 인증 하는 것) !! 

,인증서를 관리하는 것 

### 퍼블릭 키의 맹점 → A라는 사람의 퍼블릭키를 알려고 하는 것!

홍길동이 신민호인 척 했는데 서명을 하라고 했음!
홍길동이 자신의 private key로 서명을 했음 ( open ssl 라이브러리) 
그래서 홍길동이 자신의 public key를 주면서 신민호 public key야 
그래서 사람들이 서명을 해독해봤는데 public key와 일치하기 때문에 다들 믿음!

### 인증서가 맞는지 확인하는 방법

: 이슈어( 발급자 ) 가 확인해주는 것  그러면 또 이슈어의 인증이 맞는지 확인해야 한다.... 꼬리의 꼬리를 무는 문제!  ⇒ **인증서체인**

 체인이 끝나는 곳, 내가 믿는 곳, 내가 확실하게 public key를 알고 있을 때,   
   ~의 인증서를 가지고 있다!

 ⇒ **trust anchor** 

root CA 인증서는 자기 자신이 서명한다.

인증서를 누군가가 훔쳐가서 폐기해야 한다. → PKI가 하는일

Certificate Authority → 인증기관 , 우리나라엔 5개 있다. 공인인증서는 금융감독원한테 받는다. 금융감독원은 트러스트 앵커가 아니다!!!

## PKI Trust Model

### **모노폴리 모델 - 한국의 인증서 모델,독점 모델**

금융활동을 하는 고객들이 결국에 인증서를 금융감독원이 한다. 은행은 대행업체이다!!  

root CA  하나가 여러명에게 인증서를 발급하는 경우

한명이 여러명한테 나눠주는 모델이 모노폴리 모델이다. 한국모델!

### **oligarchy 모델**

root CA 가 여러개인 경우. 고객들이 입맛에 맞춰서 인증서를 발급받는다.

웹 브라우저는 이 모델을 사용하고 있다. 

예전에 피싱사이트가 너무 기승을 부려서 서버가 믿을만한 곳인지 확인해야 한다!!! 근본적인 문제는 클라이언트가 서버가 제대로된 서버인지 확인 할 길이 없었다. 현재는 모든 서버가 https 를 지원하고 있다. ssl ( 인증서를 통해서 상대를 인증 하는 것)  

브라우저가 여러 서버의 root CA에 관련된 인증서를 다 가지고 있어야 한다.

브라우저에 어떤 root CA를 가지고 있을지 결정해주는 집단이 있다. → 이 과정이 매우 정치적으로 이뤄진다. !!

그래서 저 집단에 들어가서 자신의 서버의 root CA 를 등록해야 하는 것이 중요함 

ex) 정부 관련 사이트 중 접속이 안되는 사이트 ⇒ 집단에 들어가지 못함( 정치질당함)  

### **anarchy 모델**

root CA 모델이 없는 경우, 유저 모두가 CA가 될 수 있다.

모두모두를 다 믿는 관계 , **web of trust , network 구조**

## Hash

어원 : 으깨다. → 긴 데이터를 짧게 만드는 것. , 정보의 손실이 있음.

대표적인 예 : mod p

**MD5** → 암호화에서는 안쓰이고 다른데서 쓰인다.

**SHA 1**, SHA256 → 암호하 해쉬!

해쉬가 보안에서 점점 더 중요해지고 있다.

암호통신에 직접적으로 도움을 주지는 않지만 응용분야가 존재한다.

예를 들면 privacy를 보장하는데 사용 , 또는 블락체인에 많이 사용한다.

 

### 개념

큰 도메인에 존재하는 데이터를 작은 hash space로 mapping(함수)을 시켜주는 것이다.  모든 점들이 해쉬스페이의 하나의 점으로 간다. 해쉬는 암호화가 아니다.

비둘기 집의 원리 : 비둘기가 200마리가 있을 때 100집으로 가게 된다면 충돌이 무조건 발생!!!!!!!!!

**단점** → 정보의 손실이 있다 , x와 y의 값이 다른데 같은 값으로 발생할 경우가 생긴다. 충돌이 발생한다!!!!

**응용**

전달해야 할 m의 갯수가 매우 많을 때 

메세지를 암호화안하고 해쉬를 통해 짧게 한다음 짧은 걸 서명(private)한다.

그리고 원래 메세지와 암호화된 메세지를 전달한다.

받은 사람은 암호화 된 해쉬메세지를 public key로 복호화해서 원래 메세지와 같은지 확인한다. 

**해쉬는 충돌(collision)이 일어나는데요??**

공격자는 암호화된 메세지를 조작할 수 없으니 원래 메세지를 조작하려고 한다!  

중간에서 원래 메세지를 조작해서 보낸다!! 

해쉬를 시켰을 때 복호화한 해쉬메세지랑 일치하는 m프라임을 찾게 되면 공격이 성공하게 된다. 

### ⇒ **h(M) 은 어떤 것을 가지고 있어야 이 알고리즘이 만족되나??**

1. **compression** 짧아야 한다.  → ouput은 길이가 짧아야 한다.
2.  **Efficiency** 계산하기가 빨라야 한다. → h(x) 에서 x를 계산하기 빨라야 한다.

⇒ 전통적인 hash 성질

3. h(x) = y → y에서 x를 추측할 수 없어야 한다. **One way**

4. **week collsion resistance** ⇒ 충돌 공격을 방어하겠다.

공격자가 공격하기 어려우면 방어자가 방어하기 쉽다. 이걸 막았다.

⇒ week 

해쉬값 하나와 x 를 주어졌을 때 해쉬값가 일치하는 y를 찾는것이 더 어렵다.

5. **Strong collsion resistance**

공격자가 공격하기 쉬우면 방어자가 방어하기 어렵다 이걸 막았다.

 ⇒ strong

해쉬값 하나만 주어졌을 때 원래 x,y를 찾는게 더 쉽다.

h(x) = h(y)

4가 5보다 더 어려운 이유 ⇒ birthday paradox

⇒ 암호화 hash 성질
