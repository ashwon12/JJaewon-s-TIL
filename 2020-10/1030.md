# 10월 30일의 TIL
## Linux

프로세스가 실행되면 유니크한 ID가 부여된다. 

- process ID 0 : swqpper(schedual process)

커널의 한 부분

- process ID 1 : init process

/etc/init or sbin/init
super user 이어야 사용이 가능함
절대 죽지 않는다

- process ID 2 : pagedeamon

메인메모리와 하드메모리간의 페이지로 나눠서 왔다갔다하는 프로세스

자신의 process id를 알아내는 systemcall `getpid`

## fork()

unix 커널에서 새로운 process를 만드는 유일한 방법이 fork() 이다.

```c
#inclue <sys/types.h>
#inlcude <unistd.h>

pit_t fork(void){
	return 0  // 자신의 프로세스 반환
	return the child process ID in parent process // 부모의 프로세스 ID 반환
	return -1 // error
}
```

- 복사본 형태의 프로세스 , 기존 프로세스를 그대로 실행
- 자신의 부모 프로세스를 알고 싶으면 `getppid()`
- 통상적으로 read-only 타입이다.

### 예제

```c
#include <stiod.h>
#include <sys/types.h>
#include <unistd.h>

int main(void){
	int x;
	fork();
	x=1;
	printf(" i am process %ld, and my x is %d \n",(long)getpid(),x)
	return 0;
}
```
부모와 자식 모두 fork()  이후의 값을 모두 출력을 한다.

x의 값은 같고 pid의 값만 달라진다.

### fork 이후 작동되는 순서

1. 부모 process는 통상적으로 자식들이 작동이 끝날때까지 기다린다. 
2. 먼저 close 할 파일들을 직접 지정할 수 있다. (network server)

### fork 이후 상속되는 것

1. 그룹 ID, primary 그룹 ID , 추가적인 그룹에 추가 될 수 있다.(supplementart 그룹 ID)
2. process 그룹 ID, sessionID
3. set-user-ID and set-group ID flag
4. 최근 작동된 디렉토리
5. root 디렉토리
6. file mode creation mask
7. siganl mask and dispositions

## vfork()

fork는 부모와 자식이 서로 다른 메모리 공간을 사용하기 때문에 유지보수하는데 상당한 노력들이 필요하다. 보완해서 만들어진 것이 vfork() 

⇒ vfork()는 프로세스만 만들도 ***부모의 메모리 공간을 그대로 이용***

가상의 메모리를 활용하는데 훨씬 효율적이다.

child가 항상 먼저 시작된다. 

부모는 child가 종료될때까지 기다린다.


---
## 한줄평
이론은 이해되는데 코딩 하나도 못하겠다!! 문제 하나도 못풀겠다
,,,,,,ㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠ



