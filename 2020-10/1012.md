# 10월 12일 TIL

## Linux

<br><br>

### 파일 입출력 Systemcall의 종류들

- **open()**

 버퍼 공간을 확보하여 파일을 읽거나 쓸 때 사용한다.

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fnctl.h>

int open (const char *pathname, int flags);
 //open 함수를 사용 했을 때 응답이 오는 것은 int값 
 //실패했을 경우엔 -1값 리턴
 //flag를 사용할 때 <fnctl.h> 가 필요

int open(const char *pathname, int flags, mode t mode);
 // mode argument 사용할 때 헤더파일 #include <sys/types.h> 필요
```

pathname : 경로명을 포함한 파일의 이름

flag : 파일 상태 플래그, 의사표현, 파일을 열 때 취해지는 구체적 행동

 - 기본적인 선택 , 3개중 하나만 써야함

![Untitled 1](https://user-images.githubusercontent.com/55980680/95863037-a9d16b80-0d9e-11eb-9125-cb5f9834699a.png)


 -추가적인 옵션 

![Untitled 2](https://user-images.githubusercontent.com/55980680/95863102-be156880-0d9e-11eb-8760-3a05d3773a85.png)

mode 

mode t 타입(unsigned int)

파일이 없을 경우 새로운 파일을 만들어줄 때 사용

![Untitled 3](https://user-images.githubusercontent.com/55980680/95863122-c79ed080-0d9e-11eb-83ee-039f99d85d9e.png)


![Untitled 4](https://user-images.githubusercontent.com/55980680/95863160-d1283880-0d9e-11eb-812c-713fd99c6ed6.png)


- **close() :닫기**

```c
#include <unistd.h>

int close(int fd);
//성공이면 0, 에러 발생시 -1 반환

```

파일을 닫지 않더라도 프로세스가 종료하면 모든 열려진 파일들은 자동적으로 닫힌다. 

- **create() : 파일 생성**

    새로운 파일을 만들거나 , 이미 존재하고 있는 내용을 모두 무시하고 다시 쓸 때 사용

```c
creat(pathname,mode);
open(pathname,0_WRONLY | 0_CREAT | 0_TRUNC, mode)
```

- **read() : 읽기**

```c
#include <unistd.h>

ssize t read(int filedes, void *buf,size t)
//read(파일 디크립터, 읽어온 데이터를 저장할 곳,크기)
```

 - 파일에서 원하는 크기의 데이터를 읽음

 - 리턴 값(실제 크기)

성공하면 읽은 바이트 수

파일의 끝을 만나면 0 → 읽기 종료

실패하면 -1

 - 읽을 데이터가 충분하면 

한 번에 요청한만큼 바이트를 읽어온다.

 - 읽은 데이터가 적으면

더 적게 읽어 온다. 

- **write() :쓰기**

```c
#include <unistd.h>

ssize t write(int fd,void *buf, size t nbytes)
//fd, 실제로 write하려는 데이터 위치 , write 하려고하는 데이터의 크기)
```

read write를 할려면 무조건 open을 해야 한다. 

fd가 0,1,2 이면 open없이 가능

리턴 값(실제 크기)

성공하면 읽은 바이트 수

실패하면 -1

- **lseek() : 파일의 현재 위치 이동**

```c
#include <sys.types.h>
#include <unistd.h>

off t lseek( int fd, off t offset, int whence);
//파일명, 바이트 위치 변경, 기준점
```

 lseek은 파일에 대한 임의접근을 가능하게 한다. 

파일을 열었을 때 커서가 위치를 가르키게 되는데 그 커서의 위치를 자신의 프로그램에서 변경시킬 수 있게 해준다.

파일을 처음 열었을 때 ***현재 위치는 0***이다. 파일의 시작.

파일의 읽기-쓰기 포인터의 위치, 다음에 읽거나 쓰기를 해야하는 바이트의 위치를 변경할 수 있다.

입력의 키보드(STDIN FILENO)를 받을 땐 lseek이 작동되지 않는다.

Whence : 시작 위치 정하는 방법

![Untitled 5](https://user-images.githubusercontent.com/55980680/95863206-e00eeb00-0d9e-11eb-9847-6a1c70b66e96.png)


    ```c
    fd = open ("filename",O_RDWR);
    lseek(fd,(off_t)0,SEEK_END);
    write(fd,outbuf,BUFSIZE);

    fd = open ("filename",O_WONLY|O_APPEND);
    write(fd,outbuf,BUFSIZE); // outbuf가 추가하는 값
    ```

- **dup() , dup2()**

파일 디스크립터를 복제 시켜준다.

dup() 함수는 할당 가능한 가장 작은 번호를 리턴한다.

dup2()는 원하는 fd를 지정할 수 있다.

`int dup2(int filedes, int filedse2);`

- **stat() , fstat(), lstat()**

```c
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

int stat(const char *pathname , struct stat *buf);
int fstat(int fd , struct stat *buf);

int lstat(const char *pathname , struct stat *buf);
/* 대상 파일이 심볼릭 링크인 경우에 링크가 나타내는 파일이 아니라
링크 자신의 상태를 가져온다. */
```

파일 조작 시스템 호출은 파일 상태에 대한 정보를 `stat 구조체(buffer)`에 가져온다.

- **가져올 수 있는 정보들**

  ![Untitled 6](https://user-images.githubusercontent.com/55980680/95863245-ec934380-0d9e-11eb-8ac8-5f96fa81b4ca.png)


- **access()**

```c
#include <unistd.h>

int acess(const char *pathname, int mode);
```

mode로 전해준 값의 엑세스 권한이 있는지 없는지 알려주는 시스템 콜

mode

![Untitled](https://user-images.githubusercontent.com/55980680/95863267-f4eb7e80-0d9e-11eb-86af-23196baeed45.png)

<br><br>

## 한줄평

리눅스 공부 그만하게 해주세요,,, 너무 힘들어요,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
