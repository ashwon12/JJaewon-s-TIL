# 12월 4일의 TIL

##Process

# Process Identifiers

**프로세스가 실행되면 유니크한 ID가 부여된다.** 

- process ID 0 : swqpper(schedual process)

    커널의 한 부분

- process ID 1 : init process

    /etc/init or sbin/init
    super user 이어야 사용이 가능함
    절대 죽지 않는다

- process ID 2 : pagedeamon

    가상 메모리의 페이징을 하는 ID

    메인메모리와 하드메모리간의 페이지로 나눠서 왔다갔다하는 프로세스

**자신의 process id를 알아내는 systemcall `getpid`**

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);      // returns process ID
pid_t getppid(void);     // returns parent process ID
uid_t getuid(void);      // returns real user ID
uid_t geteuid(void);     // returns effective user ID
gid_t getgid(void);      // returns real group ID
gid_t getegid(void);     // returns effective group ID
```

# fork()

unix 커널에서 새로운 process를 만드는 유일한 방법이 fork() 이다.

```c
#inclue <sys/types.h>
#inlcude <unistd.h>

pit_t fork(void){
	return 0  // 자신의 프로세스 반환
	return the child process ID in parent process // 부모의 프로세스 ID 반환
	return -1 // error
}
```

- 복사본 형태의 프로세스 , 기존 프로세스를 그대로 실행
- 자신의 부모 프로세스를 알고 싶으면`getppid()`
- 통상적으로 read-only 타입이다.
- child 는 부모의 데이터공간, 힙 , 스택 영역을 가지고 있다. ( 메모리 공간 )

## fork() - 예제

```c
#include <stiod.h>
#include <sys/types.h>
#include <unistd.h>

int main(void){
	int x;
	fork();
	x=1;
	printf(" i am process %ld, and my x is %d \n",(long)getpid(),x)
	return 0;
}
```

실행결과 : 
부모와 자식 모두 fork()  이후의 값을 모두 출력을 한다.
x의 값은 같고 pid의 값만 달라진다.

## fork 이후 작동되는 순서

1. 부모 process는 통상적으로 자식들이 작동이 끝날때까지 기다린다. 
2. 먼저 close 할 파일들을 직접 지정할 수 있다. (network server)

## fork 이후 상속되는 것

1. 그룹 ID, primary 그룹 ID , 추가적인 그룹에 추가 될 수 있다.(supplementart 그룹 ID)
2. process 그룹 ID, sessionID
3. set-user-ID and set-group ID flag
4. 최근 작동된 디렉토리
5. root 디렉토리
6. file mode creation mask
7. siganl mask and dispositions
